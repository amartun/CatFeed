#include <Wire.h>             // Подключаем бибилиотеку для работы с I2C устройствами
#include <DS3231.h>           // Подключаем библиотеку для работы с RTC DS3231

DS3231 clock;                 // Связываем объект clock с библиотекой DS3231
RTCDateTime DateTime;         // Определяем сущность структуры RTCDateTime (описанной в библиотеке DS3231) для хранения считанных с часов даты и времени
RTCAlarmTime Alarm1;          // Определяем сущность структуры RTCAlarmTime (описанной в библиотеке DS3231) для хранения считанных с первого будильника настроек даты и времени

boolean isAlarm = false;      // Логическая переменная для обработки сигнала о срабатывании будильника 
boolean alarmState = false;   // Логическая переменная для обработки индикации при срабатывании будильника
int alarmLED = 13;             // Пин, к которому подключаем индикатор срабатывания будильника (светодиод)

void alarmFunction()                                  // Функция, вызываемая при срабатывании будильника
{
  isAlarm = true;                                     // Присваиваем значение "истина" переменной для обработки срабатывания будильника
}

void setup()
{
  Serial.begin(9600);               // Инициализируем вывод данных на монитор серийного порта, со скоростью 9600 бод
  clock.begin();                    // Инициализируем работу с объектом библиотеки DS3231
  clock.enableOutput(false);        // Определяем назначение вывода SQW (INT) для генерации прерываний при сработке будильников

  clock.setDateTime(__DATE__, __TIME__);                  // Устанавливаем время на часах, основываясь на времени компиляции скетча
//  clock.setDateTime(2016, 9, 15, 0, 0, 0);              // Установка времени вручную (Год, Месяц, День, Час, Минута, Секунда)
//  setAlarm1(Дата или день, Час, Минута, Секунда, Режим)
  clock.setAlarm1(0, 0, 0, 30, DS3231_MATCH_S);           // Устанавливаем первый будильник на срабатывание в 30 сек. каждой минуты. Режим DS3231_MATCH_S сообщает о том, что ориентироваться надо на секунды.
  pinMode(alarmLED, OUTPUT);                              // Определяем пин подключения питания светодиода, как исходящий
  attachInterrupt(0, alarmFunction, FALLING);             // Задаем функцию для обработки прерывания 0 (на пине 2)
}

void loop()
{
  DateTime = clock.getDateTime();                                                 // Считываем c часов текущие значения даты и времени в сущность DateTime
  Alarm1 = clock.getAlarm1();                                                     // Считываем c первого будильника текущие настройки даты и времени в сущность Alarm1
  Serial.println(clock.dateFormat("d.m.Y H:i:s - l   ", DateTime));               // Определяем формат вывода даты и выводим на монитор серийного порта
  Serial.println("Alarm: " + String(clock.dateFormat("__ __:__:s", Alarm1)));     // Выводим настройки будильника                                
  Serial.println();                                                               // Перевод строки
  if (isAlarm)                                                                    // Если поступил сигнал о сработке будильника
  {
    digitalWrite(alarmLED, alarmState);                                           // Отправляем логическое значение выводу питания светодиода при каждом срабатывании будильника
    alarmState = !alarmState;                                                     // Меняем это значение на противоположное
    isAlarm = false;                                                              // Отключаем сигнал о сработке будильника (меняем состояние события обработки индикатора на "ложь")
    clock.clearAlarm1();                                                          // Очищаем состояние сработки будильника
  } 
  delay(30000);                                                                    // Задержка в 1 секунду
}
